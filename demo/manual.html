<html>
<head>
<title>glsl-simulator: manual input</title>
<link rel="stylesheet" href="lib/codemirror.css">
<script src="../browser/glsl-simulator-0.1.0.js"></script>
<script src="lib/codemirror.js"></script>
<script src="lib/jsDump.js"></script>
<script src="lib/mode/glsl.js"></script>

<style type="text/css">
#container {
    display: flex;
    display: -webkit-flex;
    flex-direction: row;
    -webkit-flex-direction: row;
    flex-wrap: nowrap;
    -webkit-flex-wrap: nowrap;
    justify: space-around;
    -webkit-justify: space-around;

    position: absolute;
    top: 0; right: 0; bottom: 0; left: 0;
}

#container > div {
    width: 50%;
}

#variable-editor {
    border: solid 3px #99c;
    height: 30%;
}

.input-row {
    display: -webkit-flex;
    display: flex;
    height: 30px;
}

span.input-label {
    width: 20%;
    text-align: right;
    line-height: 34px;
    padding-right: 10px;
    font-size: 18px;
    font-family: Myriad Pro, Helvetica, sans-serif;
}

table.input-cells input[type="number"] {
    font-size: 14px;
    font-family: Menlo, monospace;
    width: 6em;
}

#shader-editor {
    border: solid 3px #c99;
    height: 70%;
    overflow: scroll;
}

#results-pane {
    border: solid 3px #9c9;
    font-family: Menlo, monospace;
    font-size: 12px;
    overflow: scroll;
    white-space: pre;
}
</style>

</head>
<body>

<div id="container">
<div id="inputs">
<div id="variable-editor">
<form>
<div id="variable-list">
</div>
</form>
</div>
<div id="shader-editor">
// Sample shader from: http://glslsandbox.com/e#21330.5

/* Here's a block
comment for you.
*/

#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
// b/w remix
// tomaes.32x.de 2014.11
void main( void ) {

    vec3 col = vec3(0.1,0.2,0.3);
    vec2 pos = ( gl_FragCoord.xy / resolution.xy );

    float sd = 0.19 - (pos.y*0.004 / pos.x*0.5) - atan( pos.x + pos.y, 40.0 );
    float so = 0.22 + pos.y*0.0003/pos.x*(0.15 + sin(time*0.04+pos.x*3.5));

    float t = mod(time*0.1, 2.0) + 440.0;
    float x = mod(pos.x + t, so);
    float y = mod(pos.y + t, so*2.0);
    float d1 = mod( distance( vec2(x,y), vec2(so*0.45,so*1.05) ) + t*0.5, 0.05) * 3.0 + pos.x * 0.5;
    float d2 = mod( distance( vec2(x,y), vec2(so*0.55,so*0.95) ) + t*0.5, 0.015) * 3.0;

    if ((x-0.03 < sd) && (y-0.03 < sd*2.0))
    if ((x < sd) && (y < sd*2.0))
        col = vec3(0.2, 0.6, mix(d1, d2, 0.8) );
    else
        col = vec3(0.72, 0.25, pos.y * 0.06 + 0.3);


    float l = length(mod(t* 0.1 + col * distance(pos,vec2(pos.y,0.0)) ,0.02)*27.5); 

    if ((pos.y>0.1) && (pos.y < 0.9))
        gl_FragColor = vec4( l,l,l, 1.0 );
    else
        gl_FragColor = vec4( 0.9,0.9,0.9, 1.0);
}
</div>
</div>
<div id="results-pane">
No results yet.
</div>
</div>

<script type="text/javascript">
var editorNode = document.getElementById("shader-editor");
var resultNode = document.getElementById("results-pane");

var cm = CodeMirror(function(elt) {
    editorNode.parentNode.replaceChild(elt, editorNode);
    elt.id = editorNode.id;
}, {
    value: editorNode.textContent,
    mode: "glsl",
    lineNumbers: true
});

/* TODO:

- Provide a radio input to change shader type
- Label each input row with name and type
- Styles for the input boxes
- Label each form row as "input" or "output" variable
- When codegen result is available, provide inputs / run shader / read outputs
*/

function shaderEditorContentChanged() {
    try {
        var shader = new GLSL.Shader(cm.getValue(), GLSL.Shader.Type.Fragment);
        populateVariableEditor(shader);
        populateResults(shader);
    } catch (e) {
        resultNode.textContent = "ERROR: " + e.message;
    }
}

function shaderInputsChanged(shader, inputMap) {
    // TODO
};

function populateResults(shader) {
        while (resultNode.hasChildNodes())
            resultNode.removeChild(resultNode.lastChild);
        var printer = new GLSL.PrettyPrinter();
        resultNode.appendChild(document.createTextNode(printer.formattedText(shader.ast)));

        resultNode.appendChild(document.createTextNode(jsDump.parse(shader.ast)));

}

// Try to save inputs with same names across multiple edits.
var inputs = {};

function populateVariableEditor(shader) {
    function makeInput(variable) {
        var inputRow = document.createElement("div");
        inputRow.classList.add("input-row");
        var label = inputRow.appendChild(document.createElement("span"));
        label.classList.add("input-label");
        label.textContent = variable.name;

        var form = inputRow.appendChild(document.createElement("table"));
        form.classList.add("input-cells");

        var rowCount = 1;
        var colCount = 1;

        switch (variable.type) {
        case "float": break;
        case "vec2":  colCount = 2; break;
        case "vec3":  colCount = 3; break;
        case "vec4":  colCount = 4; break;
        case "mat2":  colCount = 2; rowCount = 2; break;
        default: break;
        }

        var elements = [];

        for (var i = 0; i < rowCount; ++i) {
            var row = document.createElement("tr");
            for (var j = 0; j < colCount; ++j) {
                var cell = document.createElement("td");
                var input = cell.appendChild(document.createElement("input"));
                input.type = "number";
                input.maxLength = 5;
                input.placeholder = "0.0";
                elements.push(input);
                row.appendChild(cell);
            }
            form.appendChild(row);
        }

        if (variable.name in inputs) {
            var existingValue = inputs[variable.name];
            for (var i = 0; i < elements.length; ++i)
                elements[i].value = existingValue[i];
        }

        function cellValueDidChange(event) {
            if (elements.indexOf(event.target) == -1)
                return;

            var value = null;
            if (elements.length === 1) {
                value = elements[0].value;
            } else {
                var value = [];
                for (var i = 0; i < elements.length; ++i)
                    value.push(elements[i].value);
            }

            inputs[variable.name] = value;
            shaderInputsChanged(shader, inputs);
        }

        form.addEventListener("input", cellValueDidChange);
        return inputRow;
    }

    var variablesNode = document.getElementById("variable-list");

    while (variablesNode.hasChildNodes())
        variablesNode.removeChild(variablesNode.lastChild);

    var uniforms = shader.uniforms;
    var attributes = shader.attributes;
    var varyings = shader.varyings;

    // TODO: add a divider and section label?
    uniforms.map(function(v) { variablesNode.appendChild(makeInput(v)); });
    if (shader.type == GLSL.Shader.Type.Fragment)
        varyings.map(function(v) { variablesNode.appendChild(makeInput(v)); });
    else
        attributes.map(function(v) { variablesNode.appendChild(makeInput(v)); });
}

cm.on("changes", shaderEditorContentChanged);

shaderEditorContentChanged();
</script>

</body>
</html>
